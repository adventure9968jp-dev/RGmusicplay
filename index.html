<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>雙軌音控台 Pro (iPad 零延遲版)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #111318; }
        ::-webkit-scrollbar-thumb { background: #2d3748; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #4a5568; }
        .loader {
            border: 3px solid #f3f3f3; border-radius: 50%; border-top: 3px solid #3b82f6;
            width: 20px; height: 20px; -webkit-animation: spin 1s linear infinite; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-[#111318] text-white">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // --- Icons ---
        const Icon = ({ children, size = 24, className = "" }) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{children}</svg>;
        const Play = (props) => <Icon {...props}><polygon points="5 3 19 12 5 21 5 3"></polygon></Icon>;
        const Square = (props) => <Icon {...props}><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></Icon>;
        const Upload = (props) => <Icon {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></Icon>;
        const Volume2 = (props) => <Icon {...props}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></Icon>;
        const X = (props) => <Icon {...props}><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></Icon>;
        const Plus = (props) => <Icon {...props}><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></Icon>;
        const Settings = (props) => <Icon {...props}><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></Icon>;
        const Zap = (props) => <Icon {...props}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></Icon>;
        const Radio = (props) => <Icon {...props}><circle cx="12" cy="12" r="2"></circle><path d="M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14"></path></Icon>;
        const Download = (props) => <Icon {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></Icon>;
        const FileJson = (props) => <Icon {...props}><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></Icon>;

        const SoundCard = ({ sound, type, isEditMode, activeBgmId, activeSfxId, playSound, removeSound, updateSound, handleFileUpload }) => {
            const isBgm = type === 'bgm';
            const isActive = isBgm ? activeBgmId === sound.id : activeSfxId === sound.id;
            const hasFile = !!sound.url;
            const colorMap = {
                slate: 'bg-slate-700 border-slate-600', red: 'bg-red-900/40 border-red-500/50 text-red-100',
                blue: 'bg-blue-900/40 border-blue-500/50 text-blue-100', green: 'bg-emerald-900/40 border-emerald-500/50 text-emerald-100',
                purple: 'bg-purple-900/40 border-purple-500/50 text-purple-100', orange: 'bg-orange-900/40 border-orange-500/50 text-orange-100',
            };
            const activeStyle = isActive ? 'border-white bg-opacity-100 shadow-[0_0_15px_rgba(255,255,255,0.4)] scale-[0.98]' : 'hover:-translate-y-1 hover:shadow-lg active:scale-95';

            if (isEditMode) {
                return (
                    <div className="bg-[#1a1c23] border border-slate-700 rounded-lg p-2 flex flex-col gap-2 relative group">
                        <button onClick={() => removeSound(sound.id, type)} className="absolute top-1 right-1 text-slate-600 hover:text-red-400 p-1"><X size={14} /></button>
                        <input type="text" value={sound.name} onChange={(e) => updateSound(sound.id, type, 'name', e.target.value)} className="bg-transparent border-b border-slate-700 focus:border-blue-500 outline-none text-xs font-medium w-full text-slate-200 pb-1 mt-1" placeholder="名稱" />
                        <div className={`h-12 border border-dashed rounded flex items-center justify-center ${hasFile ? 'border-green-500/30 bg-green-500/10' : 'border-slate-700'}`}>
                            {hasFile ? <span className="text-[10px] text-green-400">已載入</span> : <span className="text-[10px] text-slate-500">無檔案</span>}
                        </div>
                        <div className="flex justify-between items-center mt-auto">
                            <div className="flex gap-1">
                                {['red', 'blue', 'green', 'purple', 'orange'].map(c => (
                                    <button key={c} onClick={() => updateSound(sound.id, type, 'color', c)} className={`w-2.5 h-2.5 rounded-full transition-transform ${sound.color === c ? 'ring-1 ring-white scale-110' : 'opacity-40 hover:opacity-100'}`} style={{ backgroundColor: c }} />
                                ))}
                            </div>
                            <label className="cursor-pointer text-slate-400 hover:text-white transition-colors">
                                <Upload size={14} />
                                <input type="file" accept="audio/*" className="hidden" onChange={(e) => handleFileUpload(sound.id, type, e)} />
                            </label>
                        </div>
                    </div>
                );
            }
            return (
                <button onClick={() => playSound(sound.id, type)} disabled={!hasFile} className={`relative h-24 rounded-lg transition-all duration-100 ease-out flex flex-col items-center justify-center p-2 border-2 w-full ${hasFile ? `${colorMap[sound.color]} ${activeStyle}` : 'bg-[#15171e] border-slate-800 text-slate-600 cursor-not-allowed opacity-50'}`}>
                    {isActive && <div className="absolute inset-0 bg-white/10 animate-pulse rounded-lg" />}
                    <div className={`mb-1 transition-transform ${isActive ? 'scale-110' : ''}`}>{isBgm ? <Radio size={20} /> : <Zap size={20} />}</div>
                    <span className="font-bold text-xs md:text-sm tracking-wide line-clamp-2 px-1 z-10 text-center">{sound.name}</span>
                </button>
            );
        };

        function App() {
            const [bgms, setBgms] = useState([
                { id: 'b1', name: '開場背景音', url: null, color: 'blue' },
                { id: 'b2', name: '懸疑氣氛', url: null, color: 'purple' },
            ]);
            const [sfxs, setSfxs] = useState([
                { id: 's1', name: '掌聲', url: null, color: 'green' },
                { id: 's2', name: '笑聲', url: null, color: 'green' },
            ]);
            
            const [activeBgmId, setActiveBgmId] = useState(null);
            const [activeSfxId, setActiveSfxId] = useState(null);
            const [volume, setVolume] = useState(0.8);
            const [isEditMode, setIsEditMode] = useState(true);
            const [isLoading, setIsLoading] = useState(false);
            
            // 【核心修正】: 建立預先載入的音訊實體字典，不再共用單一 audio 標籤
            const audioCache = useRef({}); 

            // 監聽音量改變，即時套用給所有預載的音訊實體
            useEffect(() => {
                Object.values(audioCache.current).forEach(audio => {
                    if (audio) audio.volume = volume;
                });
            }, [volume]);

            // 將建立實體獨立成函數
            const createAudioInstance = (id, url, listType) => {
                if (audioCache.current[id]) {
                    audioCache.current[id].pause();
                    audioCache.current[id].src = "";
                }
                const audio = new Audio(url);
                audio.preload = 'auto'; // 強制瀏覽器預先解碼，消除延遲
                audio.volume = volume;
                audio.onended = () => {
                    if (listType === 'bgm') setActiveBgmId(null);
                    if (listType === 'sfx') setActiveSfxId(null);
                };
                audioCache.current[id] = audio;
            };

            const addNewButton = (type) => {
                const newSound = { id: Math.random().toString(36).substr(2, 9), name: type === 'bgm' ? `BGM ${bgms.length + 1}` : `SFX ${sfxs.length + 1}`, url: null, color: 'slate' };
                if (type === 'bgm') setBgms(prev => [...prev, newSound]); else setSfxs(prev => [...prev, newSound]);
            };

            const handleFileUpload = (id, listType, event) => {
                const file = event.target.files[0];
                if (!file) return;
                const objectUrl = URL.createObjectURL(file);
                const fileName = file.name.replace(/\.[^/.]+$/, "");
                
                // 【核心修正】：上傳當下立刻建立音訊實體
                createAudioInstance(id, objectUrl, listType);

                const updateList = listType === 'bgm' ? setBgms : setSfxs;
                const currentList = listType === 'bgm' ? bgms : sfxs;
                updateList(prev => prev.map(sound => {
                    if (sound.id === id) {
                        if (sound.url) URL.revokeObjectURL(sound.url);
                        const isDefaultName = sound.name.startsWith(listType === 'bgm' ? 'BGM' : 'SFX') || sound.name === `按鈕 ${currentList.indexOf(sound) + 1}`;
                        return { ...sound, url: objectUrl, name: isDefaultName ? fileName : sound.name };
                    }
                    return sound;
                }));
                event.target.value = null;
            };

            const updateSound = (id, listType, key, value) => {
                const updateList = listType === 'bgm' ? setBgms : setSfxs;
                updateList(prev => prev.map(s => s.id === id ? { ...s, [key]: value } : s));
            };

            const removeSound = (id, listType) => {
                if (listType === 'bgm' && activeBgmId === id) stopAll();
                if (listType === 'sfx' && activeSfxId === id) stopAll();
                
                if (audioCache.current[id]) {
                    audioCache.current[id].pause();
                    delete audioCache.current[id];
                }

                const updateList = listType === 'bgm' ? setBgms : setSfxs;
                updateList(prev => {
                    const target = prev.find(s => s.id === id);
                    if (target && target.url) URL.revokeObjectURL(target.url);
                    return prev.filter(s => s.id !== id);
                });
            };

            // 【核心修正】：播放邏輯改為呼叫預載好的實體
            const playSound = (id, type) => {
                if (isEditMode) return;
                const targetAudio = audioCache.current[id];
                if (!targetAudio) return;

                if (type === 'bgm') {
                    // 切換 BGM：停止當前播放的 BGM
                    if (activeBgmId && audioCache.current[activeBgmId]) {
                        audioCache.current[activeBgmId].pause();
                        audioCache.current[activeBgmId].currentTime = 0;
                    }
                    targetAudio.currentTime = 0;
                    targetAudio.play().then(() => setActiveBgmId(id)).catch(e => console.error("BGM Error:", e));
                } else {
                    // 切換 SFX：防誤觸設計
                    if (activeSfxId === id && !targetAudio.paused) return; // 正在播同一個，忽略
                    
                    if (activeSfxId && activeSfxId !== id && audioCache.current[activeSfxId]) {
                        audioCache.current[activeSfxId].pause();
                        audioCache.current[activeSfxId].currentTime = 0;
                    }
                    targetAudio.currentTime = 0;
                    targetAudio.play().then(() => setActiveSfxId(id)).catch(e => console.error("SFX Error:", e));
                }
            };

            const stopAll = () => {
                if (activeBgmId && audioCache.current[activeBgmId]) {
                    audioCache.current[activeBgmId].pause();
                    audioCache.current[activeBgmId].currentTime = 0;
                }
                if (activeSfxId && audioCache.current[activeSfxId]) {
                    audioCache.current[activeSfxId].pause();
                    audioCache.current[activeSfxId].currentTime = 0;
                }
                setActiveBgmId(null);
                setActiveSfxId(null);
            };

            // --- 匯出/匯入邏輯維持不變 ---
            const blobUrlToBase64 = async (url) => {
                try {
                    const response = await fetch(url);
                    const blob = await response.blob();
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                } catch (e) { return null; }
            };

            const handleExport = async () => {
                setIsLoading(true);
                try {
                    const processSounds = async (sounds) => {
                        return Promise.all(sounds.map(async (s) => {
                            if (!s.url) return s;
                            const base64 = await blobUrlToBase64(s.url);
                            return { ...s, url: null, base64Data: base64 };
                        }));
                    };
                    const exportData = { version: "1.1", timestamp: new Date().toISOString(), bgms: await processSounds(bgms), sfxs: await processSounds(sfxs) };
                    const blob = new Blob([JSON.stringify(exportData)], { type: 'application/json' });
                    const href = URL.createObjectURL(blob);
                    const link = document.createElement('a'); link.href = href; link.download = `音控台_${new Date().toISOString().slice(0,10)}.json`;
                    document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(href);
                } catch (error) { alert("匯出失敗，音檔過大導致記憶體不足。"); }
                setIsLoading(false);
            };

            const handleImport = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                setIsLoading(true); stopAll();

                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        // 清理舊的緩存
                        Object.values(audioCache.current).forEach(audio => { if(audio) {audio.pause(); audio.src="";} });
                        audioCache.current = {};

                        const restoreSounds = (sounds, listType) => {
                            return sounds.map(s => {
                                if (s.base64Data) {
                                    const byteCharacters = atob(s.base64Data.split(',')[1]);
                                    const byteNumbers = new Array(byteCharacters.length);
                                    for (let i = 0; i < byteCharacters.length; i++) byteNumbers[i] = byteCharacters.charCodeAt(i);
                                    const blob = new Blob([new Uint8Array(byteNumbers)], { type: 'audio/mpeg' });
                                    const newUrl = URL.createObjectURL(blob);
                                    
                                    // 【核心修正】：匯入時同步重建預載實體
                                    createAudioInstance(s.id, newUrl, listType);
                                    
                                    return { ...s, url: newUrl, base64Data: null };
                                }
                                return s;
                            });
                        };
                        if (data.bgms) setBgms(restoreSounds(data.bgms, 'bgm'));
                        if (data.sfxs) setSfxs(restoreSounds(data.sfxs, 'sfx'));
                        alert("匯入成功！系統已完成預先解碼。");
                    } catch (error) { alert("匯入失敗：檔案損毀"); }
                    setIsLoading(false);
                };
                reader.readAsText(file); e.target.value = null;
            };

            return (
                <div className="min-h-screen bg-[#111318] text-white p-4 font-sans flex flex-col">
                    <div className="max-w-5xl mx-auto w-full flex-1 flex flex-col gap-4">
                        <div className="bg-[#1f222b] rounded-xl p-3 shadow-lg border border-slate-800 flex flex-wrap justify-between items-center sticky top-0 z-50 gap-2">
                            <div className="flex items-center gap-2">
                                <div className="bg-blue-600 p-1.5 rounded-md"><Settings size={18} /></div>
                                <span className="font-bold hidden md:inline">iPad 零延遲音控台</span>
                            </div>

                            <div className="flex items-center gap-3 bg-[#111318] px-3 py-2 rounded-lg border border-slate-800 flex-1 justify-center md:flex-none">
                                <Volume2 size={16} className="text-slate-400" />
                                <input type="range" min="0" max="1" step="0.01" value={volume} onChange={(e) => setVolume(parseFloat(e.target.value))} className="w-20 md:w-24 accent-blue-500 h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer" />
                                <div className="w-px h-4 bg-slate-700 mx-1"></div>
                                <button onClick={stopAll} className="flex items-center gap-1 text-red-400 hover:text-red-300 transition-colors text-sm font-bold">
                                    <Square size={12} fill="currentColor" /> 停止
                                </button>
                            </div>

                            <div className="flex gap-2">
                                <label className={`flex items-center gap-1 px-3 py-1.5 rounded-md text-xs font-bold border border-slate-700 bg-slate-800 text-slate-300 hover:bg-slate-700 hover:text-white cursor-pointer transition-colors ${isLoading ? 'opacity-50 pointer-events-none' : ''}`}>
                                    {isLoading ? <div className="loader"></div> : <FileJson size={14} />}
                                    <span className="hidden sm:inline">匯入</span>
                                    <input type="file" accept=".json" className="hidden" onChange={handleImport} />
                                </label>
                                <button onClick={handleExport} disabled={isLoading} className={`flex items-center gap-1 px-3 py-1.5 rounded-md text-xs font-bold border border-slate-700 bg-slate-800 text-slate-300 hover:bg-slate-700 hover:text-white transition-colors ${isLoading ? 'opacity-50' : ''}`}>
                                    {isLoading ? <div className="loader"></div> : <Download size={14} />}
                                    <span className="hidden sm:inline">匯出</span>
                                </button>
                                <button onClick={() => { if(isEditMode) stopAll(); setIsEditMode(!isEditMode); }} className={`px-3 py-1.5 rounded-md text-xs font-bold transition-all border ${isEditMode ? 'bg-slate-700 border-slate-600' : 'bg-blue-600 border-blue-500 text-white shadow-lg shadow-blue-500/20'}`}>
                                    {isEditMode ? '完成設定' : '進入編輯'}
                                </button>
                            </div>
                        </div>

                        <div className="bg-[#1f222b] rounded-xl p-4 shadow-lg border border-slate-800/50">
                            <div className="flex items-center gap-2 mb-4 pb-2 border-b border-slate-700/50">
                                <Radio className="text-purple-400" size={18} />
                                <h2 className="text-sm font-bold text-slate-200">背景音樂 (BGM)</h2>
                                <span className="text-[10px] bg-slate-800 text-slate-400 px-2 py-0.5 rounded-full ml-auto">模式：切換重播</span>
                            </div>
                            <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-3">
                                {bgms.map(sound => <SoundCard key={sound.id} sound={sound} type="bgm" isEditMode={isEditMode} activeBgmId={activeBgmId} activeSfxId={activeSfxId} playSound={playSound} removeSound={removeSound} updateSound={updateSound} handleFileUpload={handleFileUpload} />)}
                                {isEditMode && <button onClick={() => addNewButton('bgm')} className="h-24 border-2 border-dashed border-slate-700 rounded-lg flex items-center justify-center text-slate-500 hover:text-purple-400 hover:border-purple-400/50 hover:bg-slate-800/50 transition-all"><Plus size={24} /></button>}
                            </div>
                        </div>

                        <div className="bg-[#1f222b] rounded-xl p-4 shadow-lg border border-slate-800/50 flex-1">
                            <div className="flex items-center gap-2 mb-4 pb-2 border-b border-slate-700/50">
                                <Zap className="text-yellow-400" size={18} />
                                <h2 className="text-sm font-bold text-slate-200">特效音效 (SFX)</h2>
                                <span className="text-[10px] bg-slate-800 text-slate-400 px-2 py-0.5 rounded-full ml-auto">模式：單軌鎖定</span>
                            </div>
                            <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 gap-3">
                                {sfxs.map(sound => <SoundCard key={sound.id} sound={sound} type="sfx" isEditMode={isEditMode} activeBgmId={activeBgmId} activeSfxId={activeSfxId} playSound={playSound} removeSound={removeSound} updateSound={updateSound} handleFileUpload={handleFileUpload} />)}
                                {isEditMode && <button onClick={() => addNewButton('sfx')} className="h-24 border-2 border-dashed border-slate-700 rounded-lg flex items-center justify-center text-slate-500 hover:text-yellow-400 hover:border-yellow-400/50 hover:bg-slate-800/50 transition-all"><Plus size={24} /></button>}
                            </div>
                        </div>
                        <div className="text-center text-slate-600 text-[10px]">{isEditMode ? '已啟用硬體加速預先載入，解決 iPad 切換卡頓問題。' : '準備演出！'}</div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
